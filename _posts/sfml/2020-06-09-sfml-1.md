---
title: "Making a Game in SFML: Prelude"
tags: c++ sfml
series: "Making a Game in SFML"
subtitle: "Prelude"
---

C++. The language which stikes fear into the very heart of CS students. In the age of Python and JavaScript it is mearly a fable told to scare us surely? Pointers. Segmentation faults. Manually installing libraries. The stories can't be true - **can they?**

<!--more-->

{% include series.html %}

Over the past few weeks I've been looking into getting my head around C++ - the idea of speed and power have always sounded very exciting and other languages just weren't doing it for me. Compiling to a binary also means when you want to share your new exciting project with a friend you just need to send them a single zip file, rather than an instruction list of which Python packages to install for example.

One of the most popular C++ game engines/libaries is **S**imple **F**ast **M**edia **L**ibrary (**SFML**) - I won't be covering how to install SFML here, as there are hundreds of ways to do it per system _and hundreds of people who will say I'm showing you the wrong way anyway._

So, to get started in my game development process I wanted a simple starting point - the `Hello World!` equivalent in game development. [Pong](https://www.ponggame.org/pong-no-flash.php). The classic arcade game with a painfully simple concept, hit the ball. Since my future goals would involve a complicated project I wanted to get the basics down first; this included player controls, rendering, and networking.

I decided to make a simple 'starter' template which I could then bolster for future use.

With C++ a very useful practice is the use of header files. These are descriptions of what a class/function will do when used, but not how it will do it. It allows you to abstract the structure of the class without worring about the smaller picture. I created my `Application.hpp` file as below:

1. Poll for window events (closing).
2. Read network data / User input.
3. Interpolate movement client side.
4. Send network data based on what was done this frame.
5. Render objects.

```c++
#ifndef __APPLICATION_H__
#define __APPLICATION_H__

#include "SFML/Graphics.hpp"
#include "SFML/Main.hpp"
#include "SFML/System.hpp"

class App
{
private:
  sf::RenderWindow window;

  sf::Int64 previousUpdate;
  sf::Int64 elapsedTime;

  sf::Int32 frameDelta;

public:
  App(int width, int height, sf::String title);

  void update();
  void fixedUpdate();

  void processEvents();
  void processInput();
};
#endif // __APPLICATION_H__
```
<sup style="color: #777">Don't worry about the `#ifndef __APPLICATION_H__` weirdness, it just prevents this file being included more than once by mistake.</sup>

Here you can see a basic constructor which will take the width, height, and title of the game app; 2 update functions (fixedUpdate is called after certain amount of time, update is called every frame); and 2 processing functions for events and inputs.

I expanded the constructor to initialise and launch the SFML window like so:
```c++
APPLICATION.CPP
```

At minimum the `processEvents` function must also be declared or the window will hang when launched:
```c++
PROCESS_EVENTS()
```

We'll also just clear the window and display it in the update function:
```c++
RENDER()
```

With a few example paramaters this gives us the following result:

![Woo hoo](/assets/images/MAGISFML/sfml-intro-1.JPG)

Sucess! We have opened a SFML window. 

Up next we will get into rendering shapes/sprites, and handling user inputs.